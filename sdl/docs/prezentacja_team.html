<!DOCTYPE html>
<html>
  <head>
    <title>Your Title Here</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <!-- This is template for http://remarkjs.com/ by Ole Petter Bang -->
    <!-- CSS modifcations by J. M. Lilly-->
      
    <style type="text/css">
      body { font-family: 'Georgia';letter-spacing:0.025em;}
      h1, h2, h3 {
        font-family: 'Georgia';
        font-weight: normal;
      }
      .remark-slide-content h1 { font-size: 2.4em; color:#606060;font-weight: bold;letter-spacing:0.05em;margin-top:0em}
      .remark-slide-content h2 { font-size: 1.55em;color:#606060;font-weight: bold;letter-spacing:0.05em;margin-top:0em}
      .remark-slide-content  h3 { font-size: 1.4em;color:#606060;font-weight: bold;letter-spacing:0.05em;margin-top:0em}
      .remark-slide-content p,ol,ul { font-size: 1.2em; }
      .remark-code, .remark-inline-code { font-family: 'Courier'; }
      .remark-fading { z-index: 9; } 
        
      /* Thanks to http://www.partage-it.com/animez-vos-presentations-remark-js/  (in French) */
      .remark-slide-container {transition: opacity 0.5s ease-out;opacity: 0;}
      .remark-visible {transition: opacity 0.5s ease-out;opacity: 1;}
        
      /* Two-column layout */
      .left-column {
        width: 50%;
        float: left;
      }
      .right-column {
        width: 49%;
        float: right;
        padding-top: 0em;
        margin-top: 0em;
        text-align: left;
      }    
      .footnote {  
        position:absolute;
        bottom: 1em;
        left: 14em;
        font-size: 0.7em;
       }
        
      /* Some special classes */
      .title {font-size: 3.3em; color:#606060;font-weight:bold;letter-spacing:0.05em}
      .subtitle {font-size: 1.4em}
      .author {font-size: 1.4em; color:#606060;font-weight:bold;letter-spacing:0.02em}  
      .coauthor {font-size: 1.0em; color:#606060;font-weight:bold;letter-spacing:0.02em}  
      .institution {font-size: 1.0em;}
      .date {font-size: 1.0em;font-style: italic}
      .small {font-size: 0.6em;}
      .small .remark-code {font-size: 0.8em;}

      .cite {font-size: 0.8em; color:#33AA99;font-style: italic}

      .strike {color:salmon;text-decoration:line-through}
      .center {text-align: center}
      .justify {text-align: justify;}        
      .cite_author {font-size: 0.7em; font-style: oblique; float: right;}         
      /*Set color scheme for links.*/    
      a {text-decoration: none; color: #666666;text-align:center; width: 24%}
      /*Setting link properties is particular, do not change order below*/   
      a:visited {color:#666666}
      a:hover {color:#33AA99}  
      a:active, a#active {color:#FF9700;} 
    </style>
  </head>
  <body>
    <textarea id="source">
class: center, middle

.title[SDL]     
.subtitle[Survey Domain Language]  
&nbsp;  
&nbsp;
&nbsp;              
&nbsp;              
&nbsp;              
<!--.author[Rafał Korzeniewski]  
.institution[MillwardBrown, Lab Rafał Korzeniewski]-->      
&nbsp;              
&nbsp;  
&nbsp;
.date[27 Czerwiec 2016]   
&nbsp;          
&nbsp;          
&nbsp;          
.small[[https://github.com/rkorzen/KreaturaParser/blob/master/sdl/docs/manual.md](https://github.com/rkorzen/KreaturaParser/blob/master/sdl/docs/manual.md)]       
.small[[http://rkorzen.pythonanywhere.com/parser/](http://rkorzen.pythonanywhere.com/parser/)]               


---

# Agenda

1. Język domenowy
2. Budowa ankiety
3. Narzędzia
4. Automatyzacja - możliwości i ograniczenia
5. Metodyka pracy
6. Przykłady

---

## Język domenowy

.justify[.cite[ Język dziedzinowy, dedykowany, specjalizowany (ang. domain-specific language, DSL) 

język programowania przystosowany do rozwiązywania określonej dziedziny problemów, określonej reprezentacji problemu lub określonej techniki ich rozwiązywania.

]]

.cite_author[Źródło: Wikipedia]

&nbsp;          
--

<hr/>

.center[SDL - język opisu ankiet.] 

* defuniuje pytania, sposób prezentacji i typ odpowiedzi 
* definiuje logikę *(obecnie to jest w fazie koncepcji)*
* porządkuje strukture odpowiedzi - zarówno poprzez samą automatyzację i powtarzalność jak i poprzez manipulowanie zbiorami


---

## SDL - język opisu ankiet.
&nbsp;
&nbsp;
&nbsp;


.center[
KOD SDL<br/> 
&darr; <br/> 
Reprezentacja obiektowa <br/> 
&darr; <br/> 
metody serializacji <br>
<small>(IBIS, IBM Base Professional Metadata i Routing, Syntax SPSS, inne?)</small><br/> 
]

---

## Budowa ankiety (CAWI) 

#### Różne typy pytań, np:

otwarte, zamknięte, półotwarte, higlightery, concept selecty, intuitive itp.

--

#### Różne sposoby prezentacji i interakcji:

Listy, tabele, gridy, koszyki, skale, rankingi, slidery

--

#### Relacje pomiędzy pytaniami i opdpowiedziami - logika

Filtry, losowania, ...

--

#### Warstwa wyników

Kwotowanie, zmienne, wartości, opisy.

---
## Budowa ankiety (CAWI) 


#### Kilka spotrzeżeń:

* Kwestionariusze są do siebie podobne
--

* Systemy ankiet mają podobny repertuar typów pytań
--

* Systemy ankiet mają podobny repertuar sposobów wizualizacji, prezentacji. 
--

* Respondent widzi podobne rozwiązania

.cite[W systemach do tworzenia ankiet, w oparciu o podobne do siebie dokumenty, budujemy podobne do siebie rozwiązania] 

.center[Szerokie spojrzenie | automatyzacja | optymalizacja]

I tu właśnie wkracza SDL. 

--

.center[Automatyzacja wspiera skryptera. Nie zastępuje go.]
---

## Możliwości

#### Czego SDL nie robi

* SDL nie pisze za skryptera ankiet.  
* SDL nie zwalnia z myślenia

--

#### Co SDL robi?

* automatyzuje zadania - szczególnie te bezmyślne ale pracochłonne i monotonne
* wspiera skryptera w sprawnym budowaniu skryptów 
* promuje szerokie, globalne spojrzenie na ankietę
* pomaga zoptypmalizować produkt wyniki
* ujednolica i formatuje kod

--

SDL najlepiej sprawdzi się przy odpowiednim podejściu do procesu pisania ankiety.

Mądra droga to taka, która pozwoli Ci napisać szybko dobry skrypt. 
Mądrze jest wykorzystać to co już napisałeś do innych celów.

.center[.cite[DRY -  don't repeat yourself]]


---

## Możliwości

#### To gdzie ta wartość dodana?

<ul>
<li>łatwiej</li>
<li>szybciej</li>
<li>mniej błędów</li>
<li>czytelny, jednolity kod</li>
<li>niski koszt wejścia i przeniesienia do innej technologii</li>
<li>dodatkowe korzyści - np syntax spss (numeracja w multi, koszyki w IBIS)</li>
</ul>

---

## Możliwości

#### Dlaczego łatwiej i szybciej?

* Budowa podobna do zwykłego kwestionariusza.
* Proste reguły, intuicyjne konstrukcje 
* Automatyzacja tworzenia docelowego kodu 
* Możliwość wbudowania w kod skryptów pythona
* Stosuj mockupy

--

.center[.cite[prostota | elastyczność | intuicyjność | kompleksowość]]

--

.small[Srypter w czasie pisania wykonuje wiele różnych operacji. Tworzy listy, szkielety pytań, wywołania, filtry. 
Obecne - znane mi - rozwiązania automatyzacji nie wykorzystują jej potencjału. 
Jedne zmuszają nas do rozbijania pracy na małe kawałki, które składamy w całość a inne są bardzo zamknięte (SAT)  
W SDL wskazane jest by podejść do skryptu jako do całości. 
To znacznie mniej klikania, kopiowania, przeklejania.
Jeśli coś nas stopuje to można to po prostu zasygnalizować i zostawić rozwiązanie na później.]

--
* niski koszt wejścia nowych pracowników. SDL jest prostszy do nauczenia niż IBIS czy BP

--
* reużywalność. Jeden kod, wiele możliwości. 

--
* stosunkowo mały koszt wejścia w nowe technologie - o ile udostępniają jakieś API do tworzenia ankiet

---

## Możliwości

#### Dlaczego mniej błędów?

Automat się nie myli. Co najwyżej robi coś źle. 

--

#### Czytelny, jednolity kod

Te same typy pytań zawsze sa napisane w ten sam sposób. Dobre, czytelne sformatowanie kodu ułatwia czytanie.
Dodatkowo - jako, że robi to automat - można w szablony kodu wplatać rozmaite komentarze, zakomentowane dodatkowe opcje, przykłady itd.
Wszystko wtedy może być "pod ręką"

.center[.cite[Readability counts.]]

---
## Możliwości
#### Niski koszt wejścia i przeniesienia...

* Reprezentacja SDL w małym stopniu zależy od wybranej techniki. 
* Gridy, Buckety, Single, Openy... zapisujemy w SDL tak samo dla BP jak i dla IBISa 

Jest to proste. Jest to w miarę dobrze udokumentowane. Wydaje mi się też, że jest to intuicyjne.

---

## Ograniczenia

* nowe = konieczność wyjścia poza strefę własnego komfortu i przyzwyczajeń
* Bardzo ograniczone prototypowanie. SDL automatyzuje tylko dobrze znane rozwiazania
* To nie jest jeszcze kompletne rozwiazanie. .small[(Są: Listy, categoricale, openy, gridy, koszyki. Reszta wkrótce.)]

---

<small>
W BP tknięta jest tylko strona logiki badania. Realizacji logiki jest czymś, co stanowi znaczną różnicę pomiędzy systemami. Chcąc zachować zgodność wsteczną zmuszałbym skrypterów BP do przyjmowania nawyków i myślenia z IBISa a to nie jest dobra droga. Z drugiej strony definiowanie logiki dla każdego z systemów z osobna burzy uniwersalność rozwiązania.
</small>

<small>
Rozwiązaniem było by bardziej abstrakcyjne i uniwersalne podejście do opisu logiki. Opisanie jej w SDL a następnie tłumaczona na inne systemy. To zadanie do przemyślenia i wykonania. 
Warto też pamiętać, że SDL nie ma na celu zastąpienie skryptera, a jedynie wsparcie go w powtarzalnych, nie wymagających myślenia czynnościach.
</small>

<small>
Denerwujące i ograniczające jest też na razie to, że treść pytania musi być w SDL w jednej linii. To z czasem można poprawić, choć to spora zmiana. 
</small>

---

## Metodyka pracy - Narzędzia

#### SDL
* aplikacja internetowa
--

* moduł pythona
--

* (web API? Aplikacja desktopowa?)

--

#### narzędzia wspomagajace:

* Edytor tekstowy - np. notepad++, atom, sublime
* Edytor xml - np firstobject

--

#### nie sprawdzają się:

* Boxer
* notatnik
* Word
* Słabo wypada TextPad

---

## Metodyka pracy ..

+ Stwórz sobie dobre środowisko (np ten notepad++).
+ Nie bój się dokumentacji.

#### Word
1. Spójrz na kwestionariusz jako całość.
2. Sprawdź błędy w Wordzie. 
3. Ujednolić wersjonowania płci (SDL rozpozna najpopularniejsze przykłady wersjonowania, w miarę upływu czasu możemy jego wiedzę powiększać)
4. Zrób italic i bold gdzie trzeba. Odpal makro, które zamieni formatowanie word na html.

---

## Metodyka pracy ..

#### Edytor:
* Skopuj całość kwesta z worda i wklej do edytora tekstowego.
* Idź od góry kwesta i formatuj tekst do reguł SDL. Rzeczy niepotrzebne usuwaj lub komentuj. 
* Są proste reguły. Definicja pytania wygląda zawsze tak:

  ```
  1 2   3             4     (5)    
  Q TYP IDENTYFIKATOR treść --special-markers
  kafeteria     (6)
  _             (7)
  stwierdzenia  (8)
  ```

liczby w nawiasie to pozycje obligatoryjne. Niektóre pytania mogą ich wymagać inne nie.

---

.title[Przykłady]


---
### Info page
input:

    Q L Q1_intro This is a message.
metadata output:

    Q1_intro "This is a message." info;
routing output:
    
    Q1_intro.Ask()

---

### Open question

input:

    Q O Q1_open This is open question.
metadata output:

    Q1_open "This is open question." text;
routing output:
    
    Q1_open.Ask()
---

### Numeric question
input:

    Q O Q1_numeric This is numeric question.
metadata output:

    Q1_numeric "This is numeric question."
    ' style( Width = "3em" )
    long;    
routing output:
    
    Q1_numeric.Ask()
---

### Simple list definition
input:
    
    Q DEF Brands Smth
    2 a
    5 b
    7 c 
metadata output:

    Brands - define
    {
        _2 "a",
        _5 "b",
        _7 "c"

    };
routing output: `None`

---

### Categorical single answer
input:

    Q S Brands Smth
    2   a
    7   c   
metadata output:

    Brands "Smth"
    Categorical [1..1]
    {
        _2 "a",
        _7 "c"

    };
routing output: `Brands.Ask()`

---

### Categorical multiple answer
input:

    Q M Brands Smth
    2   a
    5   b
    7   c   
metadata output:

    Brands "Smth"
    Categorical [1..1]
    {
        _2 "a",
        _5 "b",
        _7 "c"

    };

routing output: `Brands.Ask()`

---
### Categorical with defined list
input:

    Q M Q1 which of the following brands you know
    --use:BRANDS
metadata output:

    Q1 "Which of the following brands you know?"
    Categorical [1..]
    {
        use BRANDS -

    };
routing output:
    
    Q1.Ask()
---
<a name="categorical-create-list"></a>
### Categorical create list
input:

    Q S Q1 The best car brand is .. --list:CARBRANDS
    Mercedes
    Bugatti
    Porsche
metadata output:

    CARBRANDS - define
    {
        _1 "Mercedes",
        _2 "Bugatti",
        _3 "Porsche"

    };

    Q1 "The best car brand is .. "
    Categorical [1..1]
    {
        use CARBRANDS -
    };
routing output: `Q1.Ask()`

---

### Automate cafeteria id
There are several ways to automate cafeteria id's.
By default we expect that cafeteria has a numeric id, or no id at all.
cafeteria row is build like this:

    1   2         3        4  
    (id)(.d|.c)[ ]Content[](--special markers) 
Groups in () are not obligatory
    
    1 - explicite id - natural numbers
    2 - .d - DK
        .c - comment (others)
    [ ] - white space: spaces, tabs
    3 - content 
    4 - --special markers:
        --so = screen out (add screenout to routing)
        --fix

---
#### Examples
##### explicite id
input:

    Q S Q1 Content
    1 A
    2 B
    3 C
output:

    Q1 "Content"
    Categorical [1..1]
    {
        _1 "A",
        _2 "B",
        _3 "C"

    };

---

#### Examples
##### implicite id
input:

    Q S Q1 Content
    A
    B
    C
output:

    Q1 "Content"
    Categorical [1..1]
    {
        _1 "A",
        _2 "B",
        _3 "C"

    };

---

##### do it alphabetically - with big letters. We can force big letters instead of numbers:

input:

    Q DEF LIST smth --big-letters
    el 1
    el 2
output:

    LIST - define
    {
        A "el 1",
        B "el 2"

    };
TODO: Exceeding the length of the alphabet. AA AB AC etc etc... Also Warning?

---

##### `--raw-id`
Other way is with `--raw-id`. Id is based on content. Replace white space with _ and strip.
input:

    Q M Q1 COS --raw-id
    Mark 1
    Mark 2
    Mark 3
output:

    Q1 "COS "
    Categorical [1..]
    {
        Mark_1 "Mark 1",
        Mark_2 "Mark 2",
        Mark_3 "Mark 3"

    };

---

##### `--first-id`

For now the last method is `--first-id`. This means - first word treat like id.

input:

    Q M Q1 COS --first-id
    Argh Mark 1
    C Mark 2
    F Mark 3
output:

    Q1 "COS "
    Categorical [1..]
    {
        Argh "Mark 1",
        C "Mark 2",
        F "Mark 3"

    };

---

##### Easy add bold and italic
When someone ask you to add a bold or italic to some answers, you don't need to add `<i></i>` arround phrase. Just add `--i`, `--b`.

input:
    
    Q S Q1 Smth
    A --i
    B --b
    C
output:

    Q1 "Smth"
    Categorical [1..1]
    {
        _1 "<i>A</i>",
        _2 "<b>B</b>",
        _3 "C"

    };

---

##### REF NA DK
input:
    
    Q S Q1 Smth
    A --ref
    B --na
    C --dk
output:

    Q1 "Smth"
    Categorical [1..1]
    {
        - "A" REF,
        - "B" NA,
        - "C" DK

    };

---

##### cafeteria with images
###### `--images` 
.small[
input:
    
    Q S Q1 Smth --images
    A
    B
output:

    Q1 "Smth "
        [
            flametatype = "mbclickableimages"
            , toolPath = "[%ImageCacheBase%]/images/mbtools/"

        ]
    Categorical [1..1]
    {
        _1 "A"
            labelstyle(
                Image = "images\1.jpg",
                ImagePosition = "ImageOnly"
            ),
        _2 "B"
            labelstyle(
                Image = "images\2.jpg",
                ImagePosition = "ImageOnly"
            )

    };
]
---

##### cafeteria with images
###### `--images:path\to\files`
input:
    
    Q DEF Q1 Smth --images:folder\folder2
    A
    B
output:

    Q1 - define
    {
        _1 "A"
            labelstyle(
                Image = "images\folder\folder2\1.jpg",
                ImagePosition = "ImageOnly"
            ),
        _2 "B"
            labelstyle(
                Image = "images\folder\folder2\2.jpg",
                ImagePosition = "ImageOnly"
            )

    };

---

##### cafeteria with images
###### `|path\img.jpg`
input:
    
    Q S Q1 COS
    A|1.jpg
    B|c\2.jpg
output:

    Q1 "COS"
    Categorical [1..1]
    {
        _1 "A"
            labelstyle(
                Image = "images\1.jpg",
                ImagePosition = "ImageOnly"
            ),
        _2 "B"
            labelstyle(
                Image = "images\c\2.jpg",
                ImagePosition = "ImageOnly"
            )

    };

---

#### Sorting
##### `--sort`
input:

    Q DEF Brand Brand --sort
    C
    D
    A
output:

    Brand - define
    {
        _3 "A",
        _1 "C",
        _2 "D"

    };

---

#### Sorting
##### `--sort-by-id`
input:

    Q S Brand Brand --sort-by-id
    2 C
    3 D
    1 A
output:

    Brand "Brand "
    Categorical [1..1]
    {
        _1 "A",
        _2 "C",
        _3 "D"

    };

---
#### Sorting
##### combine sorting with list creation

input:

    Q M Brand Brand --sort--list:Brands
    C
    D
    A
output:

    Brands - define
    {
        _3 "A",
        _1 "C",
        _2 "D"

    };

    Brand "Brand "
    Categorical [1..]
    {
        use Brands -
    };

---

#### Randomize/Rotation
##### `--rot` - rotate cafeteria
input:
    
    Q S Q1 COS --rot
    A
    B
    C
output:

    Q1 "COS"
    Categorical [1..1]
    {
        _1 "A",
        _2 "B",
        _3 "C"

    } rot ;

Similar for `--ran`

---
#### Randomize/Rotation
##### `--statements-ran` - rotate statements
.small[
input:

    Q G Q1 COS --statements-ran
    answer a
    answer b
    _
    statment I
    statment II

output:

    Q1 "COS"
        [
            flametatype = "mbdynamicgrid"
            , toolPath = "[%ImageCacheBase%]/images/mbtools/"
        ]
    loop
    {
        _1 "statment I",
        _2 "statment II"

    } ran fields -
    (
        slice ""
        categorical [1..1]
        ...
    ) expand grid;
]
---

### Drag and Drop
#### Buckets with text
.small[
input:

    Q B dndBucketsText How familiar you are with each of these brands?<br/>
    --use:BE2A_ans_dl
    _
    --use:BRANDS
output:

    dndBucketsText "How familiar you are with each of these brands?<br/>"
        [
            flametatype = "mbdragndrop"
            , toolPath = "[%ImageCacheBase%]/images/mbtools/"
            , rowBtnType = "Text"
            ' , rowBtnWidth = 200                 ' width should be any integer > 10
            , dropType = "buckets"
        ]
    loop
    {
        use BRANDS -

    }  fields -
    (
        slice ""
        categorical [1..]
        {
            use BE2A_ans_dl -

        };
    ) expand grid;
]

---

### Drag and Drop
#### Buckets with images

.small[
input:

    Q B dndBucketsImage How familiar you are with each of these brands?<br/> --images
    --use:BE2A_ans_dl
    _
    --use:BRANDS
output:

    dndBucketsImage "How familiar you are with each of these brands?<br/>"
        [
            flametatype = "mbdragndrop"
            , toolPath = "[%ImageCacheBase%]/images/mbtools/"
            , rowBtnType = "Images"
            ' , rowBtnUseZoom = True             ' Setting to true enables a zoom icon on each of the row images that allows the respondents to view a larger version on screen.
            , dropType = "buckets"
        ]
    loop
    {
        use BRANDS -

    }  fields -
    (
        slice ""
        categorical [1..]
        {
            use BE2A_ans_dl -

        };
    ) expand grid;
]

---
### Drag and Drop
#### Exclude in buckets
.small[
input:

    Q B dndScaleTextGray Drop the brand to the relevant baskets<br/>
    The Best one --@
    Good
    Bad
    The worse one --@
    _
    --use:BRANDS
output:

    dndScaleTextGray "Drop the brand to the relevant baskets<br/>"
        [
            flametatype = "mbdragndrop"
            ...
            , dropType = "buckets"
        ]
    loop
    {
        use BRANDS -

    }  fields -
    (
        slice ""
        categorical [1..]
        {
            _1@ "The Best one",
            _2 "Good",
            _3 "Bad",
            _4@ "The worse one"

        };
    ) expand grid;
]

---
### Drag and Drop
#### Love hate scale with text buttons
.small[
input:

    Q LHS dndLoveHateScaleText How familiar you are with each og these brands?<br/>
    -5 Hate it
    -4
    -3
    -2
    -1
    0 Neutral
    1
    2
    3
    4
    5 Love it
     _
     --use:BRANDS
]

---

### Drag and Drop
#### Love hate scale with text buttons
.small[
output:

    dndLoveHateScaleText "How familiar you are with each og these brands?<br/>"
        [
            flametatype = "mbdragndrop"
            , toolPath = "[%ImageCacheBase%]/images/mbtools/"
            , rowBtnType = "Text"
            ' , rowBtnWidth = 200                 ' width should be any integer > 10
            , colImgType = "LoveHate"            ' RedBlack, Grey"
            , dropType = "scale"
        ]
    loop
    {
        use BRANDS -

    }  fields -
    (
        slice ""
        categorical [1..]
        {
            _1 "-5 Hate it",
            _2 "-4",
            _3 "-3",
            _4 "-2",
            _5 "-1",
            _6 "0 Neutral",
            _7 "1",
            _8 "2",
            _9 "3",
            _10 "4",
            _11 "5 Love it"

        };
    ) expand grid;

]

---

### Drag and Drop
#### `--images` - Love hate scale with image buttons
.small[
input:

    Q LHS dndBucketsImage How familiar you are with each og these brands?<br/>--images
    -5 Hate it
    -4
    -3
    -2
    -1
    0 Neutral
    1
    2
    3
    4
    5 Love it
    _
    --use:BRANDS

]

---


### Drag and Drop
#### `--images` - Love hate scale with image buttons
.small[
output:

    dndBucketsImage "How familiar you are with each og these brands?<br/>"
        [
            flametatype = "mbdragndrop"
            , toolPath = "[%ImageCacheBase%]/images/mbtools/"
            , rowBtnType = "Image"
            ' , rowBtnUseZoom = True             ' Setting to true enables a zoom icon on each of the row images that allows the respondents to view a larger version on screen.
            , colImgType = "LoveHate"            ' RedBlack, Grey"
            , dropType = "scale"
        ]
    loop
    {
        use BRANDS -

    }  fields -
    (
        slice ""
        categorical [1..]
        {
            _1 "-5 Hate it",
            _2 "-4",
            _3 "-3",
            _4 "-2",
            _5 "-1",
            _6 "0 Neutral",
            _7 "1",
            _8 "2",
            _9 "3",
            _10 "4",
            _11 "5 Love it"

        };
    ) expand grid;
]

---

#### Dynamic Grid
.small[
input:

    Q G Q1 COS
    answer a
    answer b
    _
    statment I
    statment II
output:

    Q1 "COS"
        [
            flametatype = "mbdynamicgrid"
            , toolPath = "[%ImageCacheBase%]/images/mbtools/"
        ]
    loop
    {
        _1 "statment I",
        _2 "statment II"

    } fields -
    (
        slice ""
        categorical [1..1]
        {
            _1 "answer a",
            _2 "answer b"

        };
    ) expand grid;
]

---
#### Dynamic Grid
##### randomize cafeteria rotate statements
.small[

input:
    
    Q G Q1 COS --ran --statements-rot
    answer a
    answer b
    _
    statment I
    statment II
output:

    Q1 "COS "
        [
            flametatype = "mbdynamicgrid"
            , toolPath = "[%ImageCacheBase%]/images/mbtools/"
        ]
    loop
    {
        _1 "statment I",
        _2 "statment II"

    } rot  fields -
    (
        slice ""
        categorical [1..1]
        {
            _1 "answer a",
            _2 "answer b"

        } ran ;
    ) expand grid;
]

---

#### Slider (Not implemented yet)
Not implemented yet

#### Click and Fly (Not implemented yet)
Not implemented yest

#### Clicakble Images 
Check single/multi with `--images`

#### Clickable Tiles (Not implemented yet)
Not implemented yet

#### Button Matrix (Not implemented yet)
Not implemented yet

#### Semantic Differential (Bi-polar) - Not implemented yet
Not implemented yet

---

### errors and validation
There are also few basic validators

#### two questions with the same id

input:

    Q S Q1 Smth
    A
    B

    Q S Q1 Smth
    A
    B

output:

    ValueError: Two questions have the same id: Q1  

---

### errors and validation
#### two positions in cafetera have the same id
input:

    Q S Q1 Smth
    1    A
    1    A
output:

    ValueError: Two positions can't have same id. Error in: Q1. Cafeteria id: 1   


---

The Zen of Python, by Tim Peters:

    Beautiful is better than ugly.
    Explicit is better than implicit.
    Simple is better than complex.
    Complex is better than complicated.
    Flat is better than nested.
    Sparse is better than dense.
    Readability counts.
    Special cases aren't special enough to break the rules.
    Although practicality beats purity.
    Errors should never pass silently.
    Unless explicitly silenced.
    In the face of ambiguity, refuse the temptation to guess.
    There should be one-- and preferably only one --obvious way to do it.
    Although that way may not be obvious at first unless you're Dutch.
    Now is better than never.
    Although never is often better than *right* now.
    If the implementation is hard to explain, it's a bad idea.
    If the implementation is easy to explain, it may be a good idea.
    Namespaces are one honking great idea -- let's do more of those!

---

.center[.title[Dziękuję]]




    </textarea>
    <!-- This is the link to the local copy of Remark -->
    <script src="liminal/javascript/remark-latest.min.js" type="text/javascript"></script>
    <!-- See discussion at https://github.com/gnab/remark/issues/222-->
    <!-- You could alternately use the libraries from remote location -->
    <!--<script src="https://gnab.github.io/remark/downloads/remark-latest.min.js" type="text/javascript"></script>-->
      
    <!-- This is the link to the remote MathJax libraries --> 
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&delayStartupUntil=configured" type="text/javascript"></script> 
    <!-- If you want to run your presentation offline, you need to download the MathJax -->
    <!-- libraries, then uncomment the line below and comment out the one above.-->
    <!--<script src="../javascript/MathJax/MathJax.js?config=TeX-AMS_HTML&delayStartupUntil=configured,local/local" type="text/javascript"></script> -->
    <!-- Note: see comment at http://stackoverflow.com/questions/19208536/mathjax-not-working-if-loaded-from-local-js-file-or-if-the-source-code-is-includ-->
      
    <script type="text/javascript"> 
      var slideshow = remark.create({navigation: {click: false}, properties: {class: "center, middle"}});

      // Setup MathJax
      MathJax.Hub.Config({
          tex2jax: {
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
          }
      });
      MathJax.Hub.Queue(function() {
          $(MathJax.Hub.getAllJax()).map(function(index, elem) {
              return(elem.SourceElement());
          }).parent().addClass('has-jax');
      });

      MathJax.Hub.Configured();
    </script>
  </body>
</html>